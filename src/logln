#!/bin/sh
# Author:     awmyhr <awmyhr@gmail.com>
# Contact:    awmyhr <awmyhr@gmail.com>
# Project:    Shell Functions
# Proj Home:  https://github.com/awmyhr/shell-functions
# Copyright:  2019 awmyhr
# License:    Apache-2.0
# Revised:    2019-07-11 # This revision is for the test-suite portion
# Created:    2019-06-28
#==============================================================================
#-- Expected globals ------------------------------------------------------
cf_blue=${cf_blue:=''}     ; cf_green=${cf_green:=''}     ; cf_white=${cf_white:=''}
cf_yellow=${cf_yellow:=''} ; cf_magenta=${cf_magenta:=''} ; cf_red=${cf_red:=''}
c_reset=${c_reset:=''}
__cononical_name__="${__cononical_name__:=${0}}"
__logln_dsf__="${__logln_dsf__:="+%Y%m%d"}"
__logln_file__="${__logln_file__:=nil}"
__logln_file_fmt__="${__logln_file_fmt__:=default}"
__logln_file_set__="${__logln_file_set__:=false}"
__logln_lvl__="${__logln_lvl__:=20}"
__logln_facility__="${__logln_facility__:=20}"
__script_debug__="${__script_debug__:=false}"
MARK="${MARK:=default}"
TASK="${TASK:=00}"
TASK_SUB="${TASK:=0}"
TASK_STEP="${TASK:=0}"
HOSTNAME="${HOSTANME:=$(hostname -f)}"
##--==
#==============================================================================
logln() {
    #:"""
    #: .. function:: logln()
    #:
    #: .. project:: Shell Functions <https://github.com/awmyhr/shell-functions>
    #:
    #: .. revision:: 2019-07-11
    #:
    #: Provides an interface similar to Python's logging module
    #:
    #: :param str log_level:     String indicating log level
    #: :param str log_string:    String to print
    #: .. note::
    #:     This was inspired by tinylogln (Copyright (c) 2017 Nagarjuna
    #:     Kumarappan), but I think there is very little left of the original
    #:     code here. See: https://github.com/nk412/tinylogln
    #:"""
    case "$(printf '%s' "${1}")" in
        debug)          __logln_action_tag='DEBG'   ; __logln_log_level_th=10 ;;
        step)           __logln_action_tag='STEP'   ; __logln_log_level_th=16 ;;
        subt)           __logln_action_tag='SUBT'   ; __logln_log_level_th=18 ;;
        info)           __logln_action_tag='INFO'   ; __logln_log_level_th=20 ;;
        task)           __logln_action_tag='TASK'   ; __logln_log_level_th=24 ;;
        note|notice)    __logln_action_tag='NOTE'   ; __logln_log_level_th=30 ;;
        mark)           __logln_action_tag='MARK'   ; __logln_log_level_th=35 ;;
        warn|warning)   __logln_action_tag='WARN'   ; __logln_log_level_th=40 ;;
        err|error)      __logln_action_tag='ERRO'   ; __logln_log_level_th=50 ;;
        merr|mark_err)  __logln_action_tag='MERR'   ; __logln_log_level_th=55 ;;
        crit|critical)  __logln_action_tag='CRIT'   ; __logln_log_level_th=60 ;;
        alert)          __logln_action_tag='ALRT'   ; __logln_log_level_th=70 ;;
        *)              __logln_action_tag='UNKN'   ; __logln_log_level_th=0  ;;
    esac
    shift

    __logln_task_code="${TASK}.${TASK_SUB}${TASK_STEP}"
    if is_true "${__logln_file_set__}" ; then
        if [ "${__logln_file_fmt__}" = 'rfc5424' ] ; then
            #-- Standard Syslog format (https://tools.ietf.org/html/rfc5424)
            __logln_priority=$(( 8 - __logln_log_level_th / 10 + 8 * __logln_facility__ ))
            printf '<%s>1 %s %s %s %s %s - %s\n' \
                "${__logln_priority}" "$(get_timestamp "${__logln_dsf__}")" \
                "${HOSTNAME}" "${__cononical_name__}" "${$}" \
                "${__logln_task_code}" "${@}" 1>&3
        else
            printf '%s %s %s: %s\n' \
                "$(get_timestamp "${__logln_dsf__}")" \
                "${__logln_action_tag}" \
                "${__logln_task_code}" "${@}" 1>&3
        fi
    fi

    if [ "${__logln_lvl__}" -le "${__logln_log_level_th}" ]; then
        if is_true "${__script_debug__}" ; then
            printf '%s %s ' "${cf_blue}$(get_timestamp "${__logln_dsf__}")" \
                               "${__logln_action_tag}${c_reset}"
        fi
        if [ "${__logln_log_level_th}" -le 10 ]; then
            #-- debug
            printf '%sdebug: %s%s\n' "${cf_green}" "${@}" "${c_reset}"
        elif [ "${__logln_log_level_th}" -le 16 ]; then
            #-- step
            printf '%s%s%s\n' "${cf_white}" "${@}" "${c_reset}"
        elif [ "${__logln_log_level_th}" -le 18 ]; then
            #-- sub-task
            printf '%s%s%s\n' "${cf_white}" "${@}" "${c_reset}"
        elif [ "${__logln_log_level_th}" -le 20 ]; then
            #-- info
            printf '%s%s%s\n' "${cf_white}" "${@}" "${c_reset}"
        elif [ "${__logln_log_level_th}" -le 24 ]; then
            #-- task
            printf '%s%s%s\n' "${cf_white}" "${@}" "${c_reset}"
        elif [ "${__logln_log_level_th}" -le 30 ]; then
            #-- note
            printf '%s%s%s\n' "${cf_white}" "${@}" "${c_reset}"
        elif [ "${__logln_log_level_th}" -le 35 ]; then
            #-- mark
            printf '%s%s%s\n' "${cf_white}" "${@}" "${c_reset}"
        elif [ "${__logln_log_level_th}" -le 40 ]; then
            #-- warning
            printf '%sWarning: %s%s\n' "${cf_yellow}" "${@}" "${c_reset}" 1>&2
        elif [ "${__logln_log_level_th}" -le 50 ]; then
            #-- error
            printf '%sError: %s%s\n' "${cf_magenta}" "${@}" "${c_reset}" 1>&2
        elif [ "${__logln_log_level_th}" -le 55 ]; then
            #-- mark-error
            printf '%sError: %s%s\n' "${cf_magenta}" "${@}" "${c_reset}" 1>&2
        elif [ "${__logln_log_level_th}" -le 60 ]; then
            #-- critical
            printf '%sCRITICAL: %s%s\n' "${cf_red}" "${@}" "${c_reset}" 1>&2
        else
            #-- alert
            printf '%sALERT: %s%s\n' "${cf_red}" "${@}" "${c_reset}" 1>&2
        fi
    fi

    return
}
##==---
#==============================================================================
if ! (return 0 2>/dev/null) ; then
    if [ "${RUN_UNIT_TEST}" = 'true' ] ; then
        cf_blue=''    ; cf_green=''   ; cf_white=''
        cf_yellow=''  ; cf_magenta='' ; cf_red=''
        c_reset=''
    fi
    if [ "${RUN_UNIT_TEST}" = 'true' ] || ! [ "$(type -t is_true 2>/dev/null)" = 'function' ] ; then
        is_true() {
            if [ "${1}" = 'true' ] ; then
                return 0
            else
                return 1
            fi
        }
    fi
    if [ "${RUN_UNIT_TEST}" = 'true' ] || ! [ "$(type -t get_timestamp 2>/dev/null)" = 'function' ] ; then
        get_timestamp() {
            printf '%s' "${1}"
        }
    fi
    if [ "${RUN_UNIT_TEST}" = 'true' ] || ! { true >&3; } 2>/dev/null ; then
        exec 3>&1 || exit 1
    fi

    logln "${@}"
fi
